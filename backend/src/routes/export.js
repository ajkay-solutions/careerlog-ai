const express = require('express');
const { requireAuth } = require('../middleware/auth');
const dbService = require('../services/database');
const PDFService = require('../services/pdfService');
const DOCXService = require('../services/docxService');

const router = express.Router();

// Initialize services
const pdfService = new PDFService();
const docxService = new DOCXService();

// Helper function to generate formatted text export
function generateFormattedExport(exportData, format) {
  const { user, period, summary, entries, projects, skills, competencies } = exportData;
  
  let content = `
========================================
WorkLog AI Export Report
========================================

User: ${user.displayName} (${user.email})
Export Date: ${summary.exportedAt}
Period: ${period.startDate} to ${period.endDate}
Format: ${format.toUpperCase()} (Text version)

========================================
Summary
========================================

Total Entries: ${summary.totalEntries}
Total Words: ${summary.totalWords}
Limited Results: ${summary.isLimited ? 'Yes' : 'No'}
${summary.isLimited ? `Showing latest ${summary.limitApplied} entries` : ''}

========================================
Journal Entries
========================================

`;

  // Add entries
  entries.forEach((entry, index) => {
    content += `
Entry ${index + 1} - ${entry.date}
${entry.isHighlight ? '⭐ HIGHLIGHTED ENTRY' : ''}
${'-'.repeat(40)}

${entry.rawText || 'No content'}

`;

    // Add AI analysis if available
    if (entry.extractedData) {
      const analysis = typeof entry.extractedData === 'string' 
        ? JSON.parse(entry.extractedData) 
        : entry.extractedData;
      
      if (analysis.projects && analysis.projects.length > 0) {
        const projectNames = analysis.projects.map(p => typeof p === 'object' ? p.name || p.title || JSON.stringify(p) : p);
        content += `Projects: ${projectNames.join(', ')}\n`;
      }
      if (analysis.skills && analysis.skills.length > 0) {
        const skillNames = analysis.skills.map(s => typeof s === 'object' ? s.name || s.skill || JSON.stringify(s) : s);
        content += `Skills: ${skillNames.join(', ')}\n`;
      }
      if (analysis.competencies && analysis.competencies.length > 0) {
        const competencyNames = analysis.competencies.map(c => typeof c === 'object' ? c.name || c.competency || JSON.stringify(c) : c);
        content += `Competencies: ${competencyNames.join(', ')}\n`;
      }
      content += '\n';
    }
  });

  // Add projects summary if included
  if (projects && projects.length > 0) {
    content += `
========================================
Projects Summary
========================================

`;
    projects.forEach(project => {
      content += `• ${project.name} (${project.status}) - ${project.entryCount} entries\n`;
    });
  }

  // Add skills summary if included
  if (skills && skills.length > 0) {
    content += `
========================================
Skills Summary
========================================

`;
    skills.forEach(skill => {
      content += `• ${skill.name} (${skill.category}) - used ${skill.usageCount} times\n`;
    });
  }

  // Add competencies summary if included
  if (competencies && competencies.length > 0) {
    content += `
========================================
Competencies Summary
========================================

`;
    competencies.forEach(comp => {
      content += `• ${comp.name} - demonstrated ${comp.demonstrationCount} times\n`;
    });
  }

  content += `
========================================
Export completed successfully
Generated by WorkLog AI
========================================
`;

  return content;
}

// GET /api/export - Export journal entries and data
router.get('/', requireAuth, async (req, res) => {
  try {
    const userId = req.user.id;
    const {
      format = 'pdf',
      startDate,
      endDate,
      includeRawText = 'true',
      includeAiAnalysis = 'true',
      includeProjects = 'true',
      includeSkills = 'true',
      includeCompetencies = 'true',
      includeMetrics = 'false',
      limit = '500' // Default limit to prevent timeouts
    } = req.query;

    console.log(`📥 Exporting data for user ${userId}, format: ${format}, period: ${startDate} to ${endDate}, limit: ${limit}`);

    // Validate date range
    if (!startDate || !endDate) {
      return res.status(400).json({
        success: false,
        error: 'Start date and end date are required'
      });
    }

    // Check for very large date ranges that might cause timeouts
    const daysDiff = Math.abs(new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24);
    if (daysDiff > 365) {
      console.warn(`⚠️ Large date range detected: ${daysDiff} days. This may cause performance issues.`);
    }

    const startTime = Date.now();
    const exportData = await dbService.executeOperation(async (prismaClient) => {
      // Build date filter
      const dateFilter = {
        userId,
        date: {
          gte: new Date(startDate),
          lte: new Date(endDate)
        }
      };

      // Get user info once (more efficient than including in every entry)
      const user = await prismaClient.user.findUnique({
        where: { id: userId },
        select: {
          displayName: true,
          email: true
        }
      });

      // Get entries for the date range with limit
      const entries = await prismaClient.entry.findMany({
        where: dateFilter,
        orderBy: { date: 'desc' },
        take: parseInt(limit),
        select: {
          id: true,
          date: true,
          rawText: true,
          extractedData: true,
          wordCount: true,
          sentiment: true,
          isHighlight: true,
          createdAt: true
        }
      });

      // Get projects for the period (if requested)
      let projects = [];
      if (includeProjects === 'true') {
        projects = await prismaClient.project.findMany({
          where: { userId },
          orderBy: { updatedAt: 'desc' }
        });
      }

      // Get skills for the period (if requested)
      let skills = [];
      if (includeSkills === 'true') {
        skills = await prismaClient.skill.findMany({
          where: { userId },
          orderBy: { usageCount: 'desc' }
        });
      }

      // Get competencies for the period (if requested)
      let competencies = [];
      if (includeCompetencies === 'true') {
        competencies = await prismaClient.competency.findMany({
          where: { userId },
          orderBy: { demonstrationCount: 'desc' }
        });
      }

      return {
        user: user || { displayName: 'Unknown User', email: 'unknown@example.com' },
        period: { startDate, endDate },
        summary: {
          totalEntries: entries.length,
          totalWords: entries.reduce((sum, entry) => sum + (entry.wordCount || 0), 0),
          dateRange: `${startDate} to ${endDate}`,
          exportedAt: new Date().toISOString(),
          limitApplied: parseInt(limit),
          isLimited: entries.length >= parseInt(limit)
        },
        entries: entries.map(entry => ({
          id: entry.id,
          date: entry.date.toISOString().split('T')[0],
          rawText: includeRawText === 'true' ? entry.rawText : undefined,
          wordCount: entry.wordCount,
          extractedData: includeAiAnalysis === 'true' ? entry.extractedData : undefined,
          sentiment: entry.sentiment,
          isHighlight: entry.isHighlight,
          createdAt: entry.createdAt
        })).filter(entry => entry.rawText || entry.extractedData), // Only include entries with content
        projects: includeProjects === 'true' ? projects : undefined,
        skills: includeSkills === 'true' ? skills : undefined,
        competencies: includeCompetencies === 'true' ? competencies : undefined
      };
    }, 'export data');

    const executionTime = Date.now() - startTime;
    console.log(`✅ Export completed in ${executionTime}ms. Found ${exportData.entries.length} entries.`);

    // Handle different export formats
    switch (format.toLowerCase()) {
      case 'json':
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', `attachment; filename="worklog-export-${startDate}-to-${endDate}.json"`);
        return res.json({
          success: true,
          data: exportData
        });

      case 'pdf':
        try {
          console.log('📄 Generating PDF export...');
          const pdfBuffer = await pdfService.generateJournalExportPDF(exportData);
          
          res.setHeader('Content-Type', 'application/pdf');
          res.setHeader('Content-Disposition', `attachment; filename="worklog-export-${startDate}-to-${endDate}.pdf"`);
          res.setHeader('Content-Length', pdfBuffer.length);
          
          return res.send(pdfBuffer);
        } catch (pdfError) {
          console.error('PDF generation failed:', pdfError);
          // Fallback to text format
          const formattedContent = generateFormattedExport(exportData, format);
          res.setHeader('Content-Type', 'text/plain; charset=utf-8');
          res.setHeader('Content-Disposition', `attachment; filename="worklog-export-${startDate}-to-${endDate}.txt"`);
          return res.send(formattedContent);
        }

      case 'docx':
        try {
          console.log('📄 Generating DOCX export...');
          const docxBuffer = await docxService.generateJournalExportDOCX(exportData);
          
          res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
          res.setHeader('Content-Disposition', `attachment; filename="worklog-export-${startDate}-to-${endDate}.docx"`);
          res.setHeader('Content-Length', docxBuffer.length);
          
          return res.send(docxBuffer);
        } catch (docxError) {
          console.error('DOCX generation failed:', docxError);
          // Fallback to text format
          const formattedContent = generateFormattedExport(exportData, format);
          res.setHeader('Content-Type', 'text/plain; charset=utf-8');
          res.setHeader('Content-Disposition', `attachment; filename="worklog-export-${startDate}-to-${endDate}.txt"`);
          return res.send(formattedContent);
        }

      default:
        return res.status(400).json({
          success: false,
          error: 'Unsupported export format. Supported formats: json, pdf, docx'
        });
    }

  } catch (error) {
    console.error('❌ Export failed:', {
      message: error.message,
      stack: error.stack,
      userId: req.user.id,
      query: req.query
    });
    
    res.status(500).json({
      success: false,
      error: 'Failed to export data',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

module.exports = router;